<!DOCTYPE html>
<html>
<head>
    <title>TiktokaStudio Thumbnail Image Generator</title>
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

    <script>


        document.addEventListener('DOMContentLoaded', function() {
            // Your code here, including adding event listeners
        // Variable to store the image folder path
        let imageFolderPath = '';
        let selectedImageFiles = [];
            // Function to parse JSON files
            function parseJSONFile(fileInput, callback) {
                const file = fileInput.files[0];
                const reader = new FileReader();
                if (!file) {
            showGeneralHint(); // Show the general hint when no JSON file is selected
            return;
        }      
                reader.onload = function(event) {
                    const jsonData = JSON.parse(event.target.result);
                    callback(jsonData);
                };

                reader.readAsText(file);
            }

            // Function to parse Excel files
            function parseExcelFile(fileInput, callback) {
                const file = fileInput.files[0];
                const reader = new FileReader();
                if (!file) {
            showGeneralHint(); // Show the general hint when no JSON file is selected
            return;
        }      
                reader.onload = function(event) {
                    const data = new Uint8Array(event.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const jsonData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName]);
                    callback(jsonData);
                };

                reader.readAsArrayBuffer(file);
            }

            // Function to parse CSV files
            function parseCSVFile(fileInput, callback) {
                const file = fileInput.files[0];
                const reader = new FileReader();
                if (!file) {
            showGeneralHint(); // Show the general hint when no JSON file is selected
            return;
        }      
                reader.onload = function(event) {
                    const csvData = event.target.result;
                    const jsonData = Papa.parse(csvData, { header: true }).data;
                    callback(jsonData);
                };

                reader.readAsText(file);
            }

            // Rendering function that takes video metadata, template, and image folder path
            async function renderImages(videoMetadata, template, imageFolderPath) {


                // Iterate through each video metadata entry
                
                for (const videoInfo of videoMetadata) {
                    let bgImage = videoInfo.bg_image; // Background image path from video metadata
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    const image = new Image();





                    // Check if bgImage is null, None, or an empty string
                    if (!bgImage || bgImage.trim() === '') {
                        // If so, randomly select an image from the image folder
                       
                        const randomIndex = Math.floor(Math.random() * selectedImageFiles.length);
                        bgImage = selectedImageFiles[randomIndex];
                        console.log('mmmmm',bgImage)
                    } else {
                    // If bgImage is an absolute path, display a hint to the user
                    const bgImageHint = document.getElementById('bgImageHint');
                    bgImageHint.style.display = 'block'; // Show the hint


                    // Hide the hint after 5 seconds
                    setTimeout(function() {
                        bgImageHint.style.display = 'none';
                    }, 5000); // 5000 milliseconds = 5 seconds                                   
                    }

                    // Load the background image

                    // Load the background image
                    if (typeof bgImage === 'string') {
                    // If bgImage is an absolute path, display a hint to the user
                    const bgImageHint = document.getElementById('bgImageHint');
                    bgImageHint.style.display = 'block'; // Show the hint

                    // Hide the hint after 5 seconds
                    setTimeout(function() {
                        bgImageHint.style.display = 'none';
                    }, 5000); // 5000 milliseconds = 5 seconds                    
                    } else {
                        // If bgImage is a File object (from the selectedImageFiles array), use a FileReader
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            image.src = event.target.result;
                        };
                        reader.readAsDataURL(bgImage);
                    }



                    // Set canvas dimensions based on template width and height
                    canvas.width = template.width;
                    canvas.height = template.height;

                    await new Promise((resolve) => {
                        image.onload = function() {
                            // Draw the background image on the canvas
                            context.drawImage(image, 0, 0, template.width, template.height);

                            // Iterate through the template texts
                            template.texts.forEach((textInfo) => {
                                const textType = textInfo.textType;
                                const fontFile = textInfo.fontFile || template.fontFile;
                                const x = textInfo.x;
                                const y = textInfo.y;
                                const fontSize = textInfo.fontSize;
                                const fontColor = textInfo.fontcolor;

                                // Use videoInfo data based on textType (e.g., heading, subheading, extra)
                                const text = videoInfo[textType];
                                console.log('type',textType,'text',text)
                                // Set font properties
                                context.font = `${fontSize}px ${fontFile}`;
                                context.fillStyle = fontColor;

                                // Split text into multiple lines if it exceeds the maxWidth
                                const maxWidth = textInfo.width;
                                const lineHeight = textInfo.height;

                                // Draw multiline text
                                drawMultilineText(context, text, { x, y }, `${fontSize}px ${fontFile}`, maxWidth, lineHeight);
                            });
                            console.log('start to download result image')
                            // Create a download link for the rendered image
                            const a = document.createElement('a');
                            a.href = canvas.toDataURL('image/jpeg');
                            a.download = `${videoInfo.videoname.split('.')[0]}.jpg`;
                            a.style.display = 'none';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);

                            resolve();
                        };
                    });
                }
            }

            // Function to calculate text size
            function calculateTextSize(text, font) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                context.font = font;
                const metrics = context.measureText(text);
                return {
                    width: metrics.width,
                    height: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
                };
            }

            // Function to calculate text lines
            function calculateTextLines(text, font, maxWidth) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = words[0];

                for (let i = 1; i < words.length; i++) {
                    const testLine = currentLine + ' ' + words[i];
                    const { width } = calculateTextSize(testLine, font);
                    if (width <= maxWidth) {
                        currentLine = testLine;
                    } else {
                        lines.push(currentLine);
                        currentLine = words[i];
                    }
                }

                lines.push(currentLine);
                return lines;
            }

            // Function to draw multiline text
            function drawMultilineText(context, text, startCoord, font, maxWidth, lineHeight) {
                const lines = calculateTextLines(text, font, maxWidth);
                let x = startCoord.x;
                let y = startCoord.y;

                context.font = font;
                context.textBaseline = 'top';

                for (const line of lines) {
                    context.fillText(line, x, y);
                    y += lineHeight;
                }
            }

            // Function to convert canvas coordinate to corner coordinate
            function convertCanvasCoordToCorner(canvasCoord, zoneWidth, zoneHeight) {
                const zoneNumber = canvasCoord - 1;
                const zoneColumn = zoneNumber % 4;
                const zoneRow = Math.floor(zoneNumber / 4);
                const cornerX = zoneColumn - zoneWidth;
                const cornerY = zoneRow - zoneHeight;
                return { x: cornerX, y: cornerY };
            }

            // Function to get default font based on language
            function getDefaultFont(language) {
                if (language === 'en') {
                    return 'Arial';
                } else if (language === 'es') {
                    return 'Arial';
                } else if (language === 'zh') {
                    return 'SimHei';
                }
            }
            function showGeneralHint() {
    const generalHint = document.getElementById('generalHint');
    generalHint.style.display = 'block'; // Show the hint


                    // Hide the hint after 5 seconds
                    setTimeout(function() {
                        generalHint.style.display = 'none';
                    }, 5000); // 5000 milliseconds = 5 seconds               

}

            // Attach the processData function to the Process button click event
            document.getElementById('process-button').addEventListener('click', function() {
                // Parse video metadata JSON, Excel, or CSV
                const videoMetaInput = document.getElementById('video-meta-input');
                const file = videoMetaInput.files[0];
                const fileExtension = file.name.split('.').pop().toLowerCase();
                if (!file) {
            showGeneralHint(); // Show the general hint when no JSON file is selected
            return;
        }      
                if (fileExtension === 'json') {

               
                    // Parse JSON file
                    parseJSONFile(videoMetaInput, function(videoMetadata) {
                        // Parse template JSON
                        parseJSONFile(document.getElementById('template-input'), function(template) {
                            // Get image folder path
                            // Retrieve the image folder input element
                            const imageFolderInput = document.getElementById('image-folder-input');
                            console.log('imageFolderInput before render.',imageFolderInput);
                            console.log('imageFolderInput.files.length before render.',imageFolderInput.files.length);

                            // Check if any folder is selected
                            if (imageFolderInput.files.length > 0) {
                                // Access the first selected folder path
                                imageFolderPath = imageFolderInput.files[0].path;
                                console.log('imageFolderInput.files[0] before render.',imageFolderInput.files[0]);

                                console.log('imageFolderInput.files[0] webkitRelativePath before render.',imageFolderInput.files[0].webkitRelativePath);
                                

                                console.log('Selected image folder path:', imageFolderPath);
                            } else {
                                console.log('No folder selected.');
                            }

                            console.log('imageFolderPath before render.',imageFolderPath);

                            // Call the rendering function
                            renderImages(videoMetadata, template, imageFolderPath);
                        });
                    });
                } else if (fileExtension === 'xlsx') {
                    // Parse Excel file
                    parseExcelFile(videoMetaInput, function(videoMetadata) {
                        // Parse template JSON
                        parseJSONFile(document.getElementById('template-input'), function(template) {
                            // Get image folder path
                            // Retrieve the image folder input element
                            const imageFolderInput = document.getElementById('image-folder-input');

                            // Check if any folder is selected
                            if (imageFolderInput.files.length > 0) {
                                // Access the first selected folder path
                                imageFolderPath = imageFolderInput.files[0].path;
                                console.log('Selected image folder path:', imageFolderPath);
                            } else {
                                console.log('No folder selected.');
                            }


                            // Call the rendering function
                            renderImages(videoMetadata, template, imageFolderPath);
                        });
                    });
                } else if (fileExtension === 'csv') {
                    // Parse CSV file
                    parseCSVFile(videoMetaInput, function(videoMetadata) {
                        // Parse template JSON
                        parseJSONFile(document.getElementById('template-input'), function(template) {
                            // Get image folder path
                            // imageFolderPath = document.getElementById('image-folder-input').files[0].path;
                            // console.log('Selected image folder path:', imageFolderPath);

                            // Retrieve the image folder input element
                            const imageFolderInput = document.getElementById('image-folder-input');

                            // Check if any folder is selected
                            if (imageFolderInput.files.length > 0) {
                                // Access the first selected folder path
                                imageFolderPath = imageFolderInput.files[0].path;
                                console.log('Selected image folder path:', imageFolderPath);
                            } else {
                                console.log('No folder selected.');
                            }


                            // Call the rendering function
                            renderImages(videoMetadata, template, imageFolderPath);
                        });
                    });
                } else {
                    alert('Unsupported file format. Please select a JSON, Excel (.xlsx), or CSV (.csv) file.');
                }
            });

            // Listen for changes in the image file input
            document.getElementById('image-folder-input').addEventListener('change', function() {
                // Update the selected image files
                selectedImageFiles = Array.from(this.files);
                console.log('Selected image files:', selectedImageFiles);
            });


        });
    </script>
</head>
<body>
<h1>TiktokaStudio Thumbnail Image Generator</h1>





<form id="file-upload-form" enctype="multipart/form-data">
    <!-- Input for video metadata JSON -->
<!-- Input for video metadata JSON, XLSX, and CSV -->
<label for="video-meta-input">Select video metadata file (JSON, XLSX, CSV):</label>
<input type="file" id="video-meta-input" accept=".json,.xlsx,.csv" required />

<br>

<p>demo video metadata file can be found https://github.com/wanghaisheng/video-publish-metadata-gpt/tree/wasm-photon</p>
<p>json file can use editor https://jsoncrack.com/editor</p>
<br>



    <!-- Input for template JSON -->
    <label for="template-input">Select template JSON:</label>
    <input type="file" id="template-input" accept=".json" required />


<br>
<p>demo template  file can be found https://github.com/wanghaisheng/video-publish-metadata-gpt/tree/wasm-photon</p>
<p>json file can use editor https://jsoncrack.com/editor</p>
<br>



    <!-- Input for selecting a local image folder -->
    <label for="image-folder-input">Select Image Folder:</label>
    <input type="file" id="image-folder-input" directory multiple />
    <br>
</form>


<br>

<br>


<button type="button" id="process-button">Generate Thumbnails</button>

<!-- Add a div to display the hint -->
<div id="bgImageHint" style="color: red; display: none;">manually set Background image feature is not yet supported.please remove 'bg_image' filed in the video meta file</div>

<!-- Add a div to display the general hint -->
<div id="generalHint" style="color: red; display: none;">Please submit video meta and template file ,background images</div>

</body>
</html>
